# Inline

`inline` is a [new soft][soft-modifier] modifier that guarantees that a definition will be inlined at the point of use.

## Inline values

This simplest form of inlining is in the form of known literal constants.

In Scala 2 we would have used a `final val` without a return type for this purpose.

```scala
final val pi = 3.141592653589793
final val pie = "🥧"
```
This did its best effort to inline the values.

Insead, if we use `inline val` we can guarantie that all references to these constants are inlined.


```scala
inline val pi = 3.141592653589793
inline val pie = "🥧"
```

```scala
val pi2 = pi + pi // val pi2 = 6.283185307179586
val pie2 = pie + pie // val pie2 = "🥧🥧"
```

As there are no direct references to `pi` and `pi2`, these definition can be removed from the generated bytecode. There are some exceptions that we will see in [later](#inline-methods).

## Inline Functions

We use `inline def` to define a function that will be inlined.

```scala
inline def logged[T](tag: String)(thunk: =>T): Unit =
  println(s"Computing $tag")
  val res = thunk
  println(s"Result of $tag: $res")
  res
```

When this funtion is called, the it is β-reeduced at compile-time removing.
This results in the removal of call and duplication of the body of the function.
Therfore the following code would would be inlined as follows

```scala
logged(getTag()) {
  computeSomthing()
}
// becomes
val tag = getTag()
def thunk = computeSomthing()
logger.log(s"Computing $tag")
val res = thunk
logger.log(s"Result of $tag: $res")
res
```

Note that by inlining we generate a `val` binding for all by-value parameters and we generate a `def` binding for each by-name paramter.
This is done to avoid changes in the order of any side effects of by-values parameters and in general to avoid duplication of the code of the paramters.
In some cases, when the arguments are pure contant values, the binding is omited and the value is inlined directly.
There is also the possibility of marking the parameter as `inline` avoid the creation of the binding as we will se [later](#inline-parameters).

It is important to understand that when a call is inlined it will not change its semantics.
This implies that the initial elaboration (overload resolution, implicit search, ...) performed while typing the body of the inline method will not change when inlined.
For example consider the following code: 

```scala
class Logger:
  def log(x: Any): Unit = println(x)

class RefinedLogger extends Logger:
  override def log(x: Any): Unit = println("Any: " + x)
  def log(x: String): Unit = println("String: " + x)

inline def logged[T](logger: Logger, x: T): Unit =
  logger.log(x)
```

The initial elaboration `logger.log(x)` tels us that we will call the `Log.log` which takes an `Any`.

```scala
logged(new RefinedLogger, "✔️")
// exapnds to
val loggeer = new RefinedLogger
val x = "✔️"
logger.log(x)
```
Eventhoug now we know that `x` is a `String` we will still `log` that recives an `Any`.
But it is now a call on `RefinedLogger` directly, the call got devirtualiezed when inlining.
Another way to interpret this, is that if `logged` is a `def` or `inline def` they would perform the same operations with some differences in performance.


### Inline parameters
One important application of inlining is to help constant folding some code.
Inline paramters do not cratte binding and their code is duplicated everywhere they are used.

```scala
inline def perimeter(inline radius: Double): Double = 
  2. * pi * radius
```
In this case we expect that if the `radius` is known then the whole computation can be done at compile-time.
We use an `inline` paramter to ensure that it is not

```scala
perimeter(5.)
// perimeter is inlined as 
2. * pi * 5.
// then pi is inlined (inline val definition from the start)
2. * 3.141592653589793 * 5.
// then constant folded to
31.4159265359
```

It is important to be careful when using an inline parameeter more that once.
Consider the following code:

```scala
inline def printPerimeter(inline radius: Double): Double =
  println(s"Perimeter (r = $radius) = ${perimeter(radius)}")
```
It works perfectly fine when a constant or reference to a val is passed to it.
```scala
printPerimeter(5.) 
// inlined as
println(s"Perimeter (r = ${5.}) = ${31.4159265359}")
```

But if something larger, possibly with sideffects is passes, then we might accidentally duplicate some work.

```scala
printPerimeter(longComputation()) 
// inlined as
println(s"Perimeter (r = ${longComputation()}) = ${6.283185307179586 * longComputation()}")
```

A useful application of inline parameters is to avoid the creation of closues of some by name parameters.

```scala
def assert1(cond: Boolean, msg: =>String) =
  if !cond then 
    throw new Exception(msg)

assert1(x, "error1")
// is inlined as
val cond = x
def msg = "error1"
if !cond then 
    throw new Exception("error1")
```
In this case we can see that a closure for `msg` is created before the condition is checked.

If we use an inline parameter insead, we can guarantee that the condition is checked before the any of the code that handles the exception is reached.
In the case of an asserion, this code should never be reached.
```scala
inline def assert2(cond: Boolean, inline msg: String) =
  if !cond then 
    throw new Exception(msg)

assert2(x, "error2")
// is inlined as
val cond = x
if !cond then 
    throw new Exception("error2")
```

### Inline Conditionals
If the condition of the inline is know constant (`true` or `false`) possibly after inlining then if is partially evaluated away and only one branch will be kept.

For example the following power function contains some `if` that will unroll the recursion and remove all function calls.

```scala
inline def power(x: Double, inline n: Int): Double =
  if (n == 0) 1.0
  else if (n % 2 == 1) x * power(x, n - 1)
  else power(x * x, n / 2)
```

```scala
power(2, 2)
// first inlines as
val x = 2
if (2 == 0) 1.0 // dead branch
else if (2 % 2 == 1) x * power(x, 2 - 1) // dead branch
else power(x * x, 2 / 2)
// partially evaluated to
val x = 2
power(x * x, 1)
// then inlined as
val x = 2
val x2 = x * x
if (1 == 0) 1.0 // dead branch
else if (1 % 2 == 1) x2 * power(x2, 1 - 1)
else power(x2 * x2, 1 / 2) // dead branch
// partially evaluated to
val x = 2
val x2 = x * x
x2 * power(x2, 0)
// then inlined as
val x = 2
val x2 = x * x
x2 * {
  if (0 == 0) 1.0
  else if (0 % 2 == 1) x * power(x, 0 - 1) // dead branch
  else power(x * x, 0 / 2) // dead branch
}
// partially evaluated to
val x = 2
val x2 = x * x
x2 * 1.0
```

Now imagine if we do not know the value of `n`
```scala
power(2, unkownNumber)
// first inlines as
val x = 2
if (unkownNumber == 0) 1.0
else if (unkownNumber % 2 == 1) x * power(x, unkownNumber - 1)
else power(x * x, unkownNumber / 2)
// then inlined as
val x = 2
if (unkownNumber == 0) 1.0
else if (unkownNumber % 2 == 1) x * {
  if (unkownNumber - 1 == 0) 1.0
  else if ((unkownNumber - 1) % 2 == 1) x2 * power(x2, unkownNumber - 1 - 1)
  else power(x2 * x2, (unkownNumber - 1) / 2)
}
else {
  val x2 = x * x
  if (unkownNumber / 2 == 0) 1.0
  else if ((unkownNumber / 2) % 2 == 1) x2 * power(x2, unkownNumber / 2 - 1)
  else power(x2 * x2, unkownNumber / 2 / 2)
}
// Oops this will never finish compiling
```

Instead, we can use the `inline if` variant of `if` that ensure that the branching desition is performed at compiletime.
It will always remove the if after inlining and keep a single branch before inlining the contents of the branch.
If does not have constant condition it will emmit an error and stop inlining.

```scala
inline def power(x: Double, inline n: Int): Double =
  inline if (n == 0) 1.0
  else inline if (n % 2 == 1) x * power(x, n - 1)
  else power(x * x, n / 2)
```

```scala
power(2, 2) // Ok
power(2, unkownNumber) // error
```

### Inline Matches
*Coming soon*

## Inline Methods
*Coming soon*

## Transparent Inline
*Coming soon*

## scala.compiletime
The package `scala.compiletime` provides useful metaprogramming abstractions that can be used within `inline` functions to provide custom semantics.

See more [here][compiletime].

## Macros
Inlinining is also the core mechanism used to write macros.
Macros provide a way to control the code generation and analisis after the call is inlined.


```scala
inline def power(x: Double, inline n: Int) = ${ powerCode('x, 'n)  }

private def powerCode(using QuoteContext)(x: Expr[Double], n: Expr[Int]): Expr[Double] = ...
```

⮕ Continue to [Scala 3 macros][macros]

[best-practices]: /docs/best-practices.md
[compiletime]: /docs/compiletime.md
[macros]: /docs/macros.md
[references]: /docs/references.md
[soft-modifier]: https://dotty.epfl.ch/docs/reference/soft-modifier.html
